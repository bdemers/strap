#!/usr/bin/env bash
# Summary: Runs strap to ensure your machine is fully configured
# Usage: strap run

# This script was initially based on Mike McQuaid's strap project, but now has a ton of changes:
# https://github.com/MikeMcQuaid/strap

set -Eeuo pipefail # https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/

STRAP_DEBUG="${STRAP_DEBUG:-}" && [ -n "$STRAP_DEBUG" ] && set -x
SUDO_PID="${SUDO_PID:-}"
command -v 'strap::lib::import' >/dev/null || { echo "strap::lib::import is not available" >&2; exit 1; }
strap::lib::import io || source ../lib/io.sh
strap::lib::import logging || source ../lib/logging.sh
strap::lib::import sudo || source ../lib/sudo.sh
strap::lib::import fs || source ../lib/fs.sh
strap::lib::import pkg || source ../lib/pkg.sh

STRAP_DEBUG="${STRAP_DEBUG:-}"
STRAP_SCRIPT="${STRAP_SCRIPT:-}" && [[ -z "$STRAP_SCRIPT" ]] && echo "STRAP_SCRIPT is not set" && exit 1
STRAP_HOME="${STRAP_HOME:-}" && [[ -z "$STRAP_HOME" ]] && echo "STRAP_HOME is not set" && exit 1
STRAP_USER_HOME="${STRAP_USER_HOME:-}" && [[ -z "$STRAP_USER_HOME" ]] && echo "STRAP_USER_HOME is not set" && exit 1
STRAP_CMD_DIR="${STRAP_CMD_DIR:-}" && [[ -z "$STRAP_CMD_DIR" ]] && echo "STRAP_CMD_DIR is not set" && exit 1
STRAP_LIB_DIR="${STRAP_LIB_DIR:-}" && [[ -z "$STRAP_LIB_DIR" ]] && echo "STRAP_LIB_DIR is not set" && exit 1

CLT_PLACEHOLDER="${CLT_PLACEHOLDER:-}"
STRAP_STEP=''
STRAP_SUCCESS=''
STRAP_QUIET_FLAG="-q"
Q="$STRAP_QUIET_FLAG"

STRAP_ISSUES_URL="https://github.com/ultimatedotfiles/strap/issues/new"

array_contains() {
  local -r arr="${1:-}" value="${2:-}"
  for e in "${arr[@]}"; do [[ "$e" = "$value" ]] && return 0; done
  return 1
}

set -x
STRAP_RUN_HOOK_PACKAGES=()
# getopts loop logic from https://stackoverflow.com/a/28466267/407170
declare args="${@:-}"
while getopts "p:-:" arg ${args}; do
  case "$arg" in
    - )  LONG_OPTARG="${OPTARG#*=}"
         case $OPTARG in
           with-hook-package=?* )
             if [[ "${#STRAP_RUN_HOOK_PACKAGES[@]}" -eq 0 ]] || \
                ! array_contains "${STRAP_RUN_HOOK_PACKAGES[@]}" "${LONG_OPTARG}" ]]; then # prevent adding the same package more than once
               STRAP_RUN_HOOK_PACKAGES+=("$LONG_OPTARG")
             fi
             ;;
           with-hook-package* )  echo "No arg for --$OPTARG option" >&2; exit 2 ;;
           '' )        break ;; # "--" terminates argument processing
           * )         echo "Illegal option --$OPTARG" >&2; exit 2 ;;
         esac ;;
    \? ) exit 2 ;;  # getopts already reported the illegal option
  esac
done
shift $((OPTIND-1)) # remove parsed options and args from $@ list
set +x
echo "packages: ${STRAP_RUN_HOOK_PACKAGES[@]}"

# Are we running interactive?
STRAP_INTERACTIVE='' # assume not interactive by default
[[ -t "0" || -p /dev/stdin ]] && STRAP_INTERACTIVE="1" # we're interactive

cleanup() {
  set +e
  rm -f "$CLT_PLACEHOLDER"
  if [ -z "$STRAP_SUCCESS" ]; then
    if [ -n "$STRAP_STEP" ]; then
      echo "!!! $STRAP_STEP FAILED" >&2
    else
      echo "!!! FAILED" >&2
    fi
    if [ -z "$STRAP_DEBUG" ]; then
      echo "!!! Run '$0 --debug' for debugging output." >&2
      echo "!!! If you're stuck: file an issue with debugging output at:" >&2
      echo "!!!   $STRAP_ISSUES_URL" >&2
    fi
  fi
}
# Trap any exit call:
trap 'cleanup' EXIT

echo -e "\n${FONT_BOLD}Bootstrapping your machine. Here we go!${FONT_CLEAR}\n"

println() {
  local file="${1:-}"
  local msg="${2:-}"
  echo "$msg" >> "$file"
}

[ "$STRAP_USER" = "root" ] && strap::abort "Run 'strap run' as yourself, not root."
groups | grep $Q admin || strap::abort "Add $STRAP_USER to the admin group."

# Initialize sudo access:
strap::sudo::enable

#############################################################
# System Defaults
#############################################################

strap::bot "System Defaults"

# --------------

strap::running "Checking security settings"
defaults write com.apple.Safari com.apple.Safari.ContentPageGroupIdentifier.WebKit2JavaEnabled -bool false
defaults write com.apple.Safari com.apple.Safari.ContentPageGroupIdentifier.WebKit2JavaEnabledForLocalFiles -bool false
sudo defaults write com.apple.screensaver askForPassword -int 1
sudo defaults write com.apple.screensaver askForPasswordDelay -int 0
sudo defaults write /Library/Preferences/com.apple.alf globalstate -int 1
sudo launchctl load /System/Library/LaunchDaemons/com.apple.alf.agent.plist 2>/dev/null

#if [ -n "$STRAP_GIT_NAME" ] && [ -n "$STRAP_GIT_EMAIL" ]; then
#  sudo defaults write /Library/Preferences/com.apple.loginwindow \
#    LoginwindowText \
#    "Found this computer? Please contact $STRAP_GIT_NAME at $STRAP_GIT_EMAIL."
#fi
strap::ok

# --------------

# Check and enable full-disk encryption.
strap::running "Checking full-disk encryption status"
if fdesetup status | grep $Q -E "FileVault is (On|Off, but will be enabled after the next restart)."; then
  strap::ok
elif [ -n "$STRAP_INTERACTIVE" ]; then
  strap::action "Enabling full-disk encryption on next reboot:"
  sudo fdesetup enable -user "$STRAP_USER" | tee ~/Desktop/"FileVault Recovery Key.txt"
  strap::ok
else
  echo && strap::abort "Run 'sudo fdesetup enable -user \"$STRAP_USER\"' to enable full-disk encryption."
fi

# --------------

strap::running "Checking keyboard and finder settings"
# speed up the keyboard.  Defaults are *slow* for developers:
restart_finder=false
defaults write -g KeyRepeat -int 2
defaults write -g InitialKeyRepeat -int 14
if [ "$(defaults read com.apple.finder AppleShowAllFiles)" != "YES" ]; then
  defaults write com.apple.finder AppleShowAllFiles YES; # show hidden files
  restart_finder=true
fi
if [ "$(defaults read NSGlobalDomain AppleShowAllExtensions)" != "1" ]; then
  defaults write NSGlobalDomain AppleShowAllExtensions -bool true # show all file extensions
  restart_finder=true
fi
[ $restart_finder = true ] && sudo killall Finder >/dev/null 2>&1
strap::ok

# --------------

strap::bot "Xcode Developer Tools"

strap::running "Checking Xcode Developer Tools"
XCODE_DIR=$(xcode-select -print-path 2>/dev/null || true)
if [ -z "$XCODE_DIR" ] || ! [ -f "$XCODE_DIR/usr/bin/git" ] || ! [ -f "/usr/include/iconv.h" ]; then

  strap::action "Installing Xcode Command Line Tools"
  CLT_PLACEHOLDER="/tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress"
  sudo touch "$CLT_PLACEHOLDER"
  CLT_PACKAGE=$(softwareupdate -l | grep -B 1 -E "Command Line (Developer|Tools)" | \
                awk -F"*" '/^ +\*/ {print $2}' | sed 's/^ *//' | head -n1)
  sudo softwareupdate -i "$CLT_PACKAGE"
  sudo rm -f "$CLT_PLACEHOLDER"
  if ! [ -f "/usr/include/iconv.h" ]; then
    if [ -n "$STRAP_INTERACTIVE" ]; then
      strap::action "Requesting user install of Xcode Command Line Tools"
      xcode-select --install
    else
      echo
      strap::abort "Run 'xcode-select --install' to install the Xcode Command Line Tools."
    fi
  fi
fi
strap::ok

# Check if the Xcode license is agreed to and agree if not.
xcode_license() {
  if /usr/bin/xcrun clang 2>&1 | grep $Q license; then
    if [ -n "$STRAP_INTERACTIVE" ]; then
      strap::running "Asking for Xcode license confirmation"
      sudo xcodebuild -license
      strap::ok
    else
      strap::abort "Run 'sudo xcodebuild -license' to agree to the Xcode license."
    fi
  fi
}
xcode_license

# --------------

strap::bot "Apple Software Updates"

strap::running "Checking Apple software updates"
if ! sudo softwareupdate -l 2>&1 | grep -q 'No new software available.'; then
  strap::action "Installing Apple software updates. This could take a while"
  echo
  sudo softwareupdate --install --all
  xcode_license
fi
strap::ok

#############################################################
# Shell init files:
#############################################################

strap::bot "Shell Init Files"

STRAP_SHELL=$(basename "$SHELL")
STRAP_SHELL_INIT_FILE="${STRAP_USER_HOME:-}/straprc"
file="$STRAP_SHELL_INIT_FILE"

file_existed=false && [[ -f "$file" ]] && file_existed=true
strap::fs::file::ensure "$file" 'u+rw' '~/.strap/straprc'
[[ "$file_existed" != true ]] && cat "$STRAP_HOME/etc/profile.d/straprc" > "$file"

declare -a filenames=(".bashrc" ".zshrc")
for filename in "${filenames[@]}"; do

  file="$HOME/$filename"

  strap::fs::file::ensure "$file" 'u+rw' "~/$filename"

  strap::running "Checking ~/.strap/straprc referenced in ~/$filename"
  if ! grep -q "$STRAP_SHELL_INIT_FILE" "$file"; then
    strap::action "Enabling ~/.strap/straprc in ~/$filename"
    println "$file" ''
    println "$file" '# strap:begin'
    println "$file" "[ -f \"$STRAP_SHELL_INIT_FILE\" ] && . \"$STRAP_SHELL_INIT_FILE\""
    println "$file" '# strap:end'
  fi
  strap::ok
done

file="$HOME/.bash_profile"
strap::fs::file::ensure "$file" 'u+rw' '~/.bash_profile'

strap::running "Checking ~/.bashrc in ~/.bash_profile per bash user guide recommendations"
if ! grep -q "bashrc" "$file"; then
  println "$file" ''
  println "$file" '# strap:begin'
  println "$file" '# source .bashrc from within .bash_profile per bash user guide: '
  println "$file" '# https://www.gnu.org/software/bash/manual/html_node/Bash-Startup-Files.html'
  println "$file" '[ -f "$HOME/.bashrc" ] && . "$HOME/.bashrc"'
  println "$file" '# strap:end'
fi
strap::ok

#############################################################
# Homebrew:
#############################################################

strap::bot "Homebrew"

strap::running "Checking Homebrew"
if command -v brew >/dev/null 2>&1; then
  strap::ok
  strap::running "Checking Homebrew updates"
  brew update >/dev/null
  brew upgrade
else
  strap::action "Installing Homebrew"
  yes '' | /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)";
fi
strap::ok

strap::lib::import brew || source ../lib/brew.sh

strap::running "Checking ~/.strap/straprc check for homebrew bin \$PATH entry"
if ! grep -q "homebrew:begin" $STRAP_SHELL_INIT_FILE; then
  strap::action "Adding ~/.strap/straprc check for homebrew bin \$PATH entry"
  file="$STRAP_HOME/etc/profile.d/homebrew.sh"
  [[ ! -f "$file" ]] && strap::abort "Invalid strap installation. Missing file: $file"
  echo "" >> "$STRAP_SHELL_INIT_FILE"
  cat "$file" >> "$STRAP_SHELL_INIT_FILE"
fi
strap::ok

#strap::running "Checking Homebrew Cask:"
#if ! brew tap | grep ^caskroom/cask$ >/dev/null 2>&1; then
#  strap::action "Tapping caskroom/cask"
#  brew tap caskroom/cask
#fi
#strap::ok
#
#strap::running "Checking Homebrew Versions:"
#if ! brew tap | grep ^caskroom/versions$ >/dev/null 2>&1; then
#  strap::running "Tapping caskroom/versions..."
#  brew tap caskroom/versions
#fi
#strap::ok
#
#strap::running "Checking Homebrew updates:"
#brew update >/dev/null
#brew upgrade
#strap::ok

#############################################################
# Homebrew:
#############################################################

strap::bot "Git & GitHub"

strap::brew::ensure 'git'
strap::brew::ensure 'jq' # needed for parsing github responses

file="$HOME/.gitconfig"
strap::fs::file::ensure "$file" 700 "~/.gitconfig"

strap::lib::import git || source ../lib/git.sh
strap::lib::import github || source ../lib/github.sh

strap::git::config::ensure core.autocrlf input
strap::git::config::ensure push.default simple
strap::git::config::ensure branch.autosetupmerge always
if strap::git::credential::osxkeychain::available ; then
  strap::git::config::ensure credential.helper osxkeychain
fi

strap::running "Checking GitHub username"
strap::github::user::ensure
strap::ok
github_username="$(strap::github::user::get)"

strap::running "Checking GitHub API Token"
github_token="$(strap::github::token::find "$github_username")"
if [[ -n "$github_token" ]]; then
  strap::ok
  strap::running "Checking GitHub API Token validity"
  if ! strap::github::api::token::is_valid "$github_token"; then
    strap::action "Deleting invalid GitHub token from local storage."
    strap::github::token::delete
    github_token='' # clear to ensure a new one is created next
  fi
  strap::ok
fi
if [[ -z "$github_token" ]]; then
  strap::action "Creating new GitHub API Token"
  strap::github::api::token::create "$github_username"
  github_token="$(strap::github::token::find "$github_username")"
  [[ -z "$github_token" ]] && strap::abort "Unable to obtain newly-created GitHub API token"
  strap::ok
fi

strap::running "Checking git config user.email"
STRAP_GIT_EMAIL="$(git config --global user.email || true)"
if [[ -z "$STRAP_GIT_EMAIL" ]]; then
  STRAP_GIT_EMAIL="$(strap::github::api::user::email "$github_token" || true)"
  if [[ -z "$STRAP_GIT_EMAIL" ]]; then
    strap::readval STRAP_GIT_EMAIL "Enter your email address" false true
  fi
  strap::action "Setting git config user.email = $STRAP_GIT_EMAIL"
  git config --global user.email "$STRAP_GIT_EMAIL"
fi
strap::ok

strap::running "Checking git config user.name"
STRAP_GIT_NAME="$(git config --global user.name || true)"
if [[ -z "$STRAP_GIT_NAME" ]]; then
  STRAP_GIT_NAME="$(strap::github::api::user::name || true)"
  if [[ -z "$STRAP_GIT_NAME" ]]; then
    STRAP_GIT_NAME="$(id -F)"
  fi
  if [[ -z "$STRAP_GIT_NAME" ]]; then
    strap::readval STRAP_GIT_NAME "Enter your first and last name" false true
  fi
  strap::action "Setting git config user.name = $STRAP_GIT_NAME"
  git config --global user.name "$STRAP_GIT_NAME"
fi
strap::ok


#############################################################
# SSH:
#############################################################

strap::bot "SSH"

strap::brew::ensure openssl

strap::lib::import ssh || source ../lib/ssh.sh

dir="$HOME/.ssh"
strap::fs::dir::ensure "$dir" 700 "~/.ssh"
strap::fs::file::ensure "$dir/authorized_keys" 600 "~/.ssh/authorized_keys"
ssh_known_hosts_file="$dir/known_hosts"
strap::fs::file::ensure "$ssh_known_hosts_file" 600 "~/.ssh/known_hosts"
file="$dir/config"
strap::fs::file::ensure "$file" 600 "~/.ssh/config"

if strap::semver::compare "$STRAP_OS_VERSION" '>=' '10.12.2'; then

  strap::running "Checking 'Host *' entry in ~/.ssh/config"
  file_contents="$(cat "$file")"
  all_hosts_entry="$(echo "$file_contents" | awk '/^Host \*/{p=1}/^ *$/{p=0}p')"
  if [[ -n "$all_hosts_entry" ]]; then
    strap::ok

    strap::running "Checking 'AddKeysToAgent' for 'Host *' entry in ~/.ssh/config"
    if ! echo "$all_hosts_entry" | grep -q 'AddKeysToAgent'; then
      # The 'Host *' directive doesn't have an AddKeysToAgent line - add one:
      strap::action "Adding 'AddKeysToAgent yes' for 'Host *' entry in ~/.ssh/config"
      file_contents="$(echo "$file_contents" | awk '1;/Host \*/{print "  AddKeysToAgent yes"}')"
    fi
    strap::ok

    strap::running "Checking 'UseKeychain' for 'Host *' entry in ~/.ssh/config"
    if ! echo "$all_hosts_entry" | grep -q 'UseKeychain'; then
      # The 'Host *' directive doesn't have a UseKeychain line - add one:
      strap::action "Adding 'UseKeychain yes' for 'Host *' entry in ~/.ssh/config"
      file_contents="$(echo "$file_contents" | awk '1;/Host \*/{print "  UseKeychain yes"}')"
      all_hosts_entry="$(echo "$file_contents" | awk '/^Host \*/{p=1}/^ *$/{p=0}p')"
    fi
    strap::ok

    # persist changes:
    echo "$file_contents" > "$file"

  else # no all hosts entry - add one:
    strap::action "Creating global 'Host *' entry in ~/.ssh/config"
    [[ -z "$file_contents" ]] && echo '' >> "$file"
    echo 'Host *' >> "$file"
    echo '  UseKeychain yes' >> "$file"
    echo '  AddKeysToAgent yes' >> "$file"
    strap::ok
  fi
fi
chmod 600 "$file"

ssh_key="$dir/id_rsa"
ssh_pub_key="${ssh_key}.pub"

strap::ssh::idrsa::passphrase::ensure

strap::running "Checking ~/.ssh/id_rsa keypair"
if [ ! -f "$ssh_key" ]; then

  ssh_agent_pid=$(ps aux|grep '[s]sh-agent -s'|sed -E -n 's/[^[:space:]]+[[:space:]]+([[:digit:]]+).*/\1/p')
  if [ -z "$ssh_agent_pid" ]; then
    ssh-agent -s >/dev/null
  fi

  strap::action "Creating ~/.ssh/id_rsa keypair"

  strap::ssh::idrsa::passphrase::delete # remove whatever might have existed
  ssh_key_passphrase="$(strap::ssh::idrsa::passphrase::create)"
  strap::ssh::idrsa::passphrase:save "$ssh_key_passphrase"

  # TODO: STRAP_GIT_EMAIL can be a github noreply address - in this case, we want the private/primary email instead
  ssh-keygen -t rsa -b 4096 -C "Strap auto-generated RSA key for $STRAP_GIT_EMAIL" -P "$ssh_key_passphrase" -f "$ssh_key" -q

  expect << EOF
    spawn ssh-add -K $ssh_key
    expect "Enter passphrase"
    send "$ssh_key_passphrase\r"
    expect eof
EOF

fi
strap::ok

strap::fs::file::ensure "$ssh_key" 400 "~/.ssh/id_rsa"
strap::fs::file::ensure "$ssh_pub_key" 400 "~/.ssh/id_rsa.pub"


#############################################################
# GitHub SSH:
#############################################################

strap::bot "GitHub SSH"

github_ssh_known_host_entry="github.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDbO9IDSwBK6TbQa+PXYPCPy6rbTrTtw7PHkccKrpp0yVhp5HdEIcKr6pLlVDBfOLX9QUsyCOV0wzfjIJNlGEYsdlLJizHhbn2mUjvSAHQqZETYP81eFzLQNnPHt4EVVUh7VfDESU84KezmD5QlWpXLmvU31/yMf+Se8xhHTvKSCZIFImWwoG6mbUoWf9nzpIoaSjB+weqqUUmpaaasXVal72J+UX2B+2RPW3RcT0eOzQgqlJL3RKrTJvdsjE3JEAvGq3lGHSZXy28G3skua2SmVi/w4yCE6gbODqnTWlg7+wC604ydGXA8VJiS5ap43JXiUFFAaQ=="

strap::running "Checking github.com in ~/.ssh/known_hosts"
if ! grep "^github.com" "$ssh_known_hosts_file" >/dev/null 2>&1; then
  strap::action "Adding github.com to ~/.ssh/known_hosts"
  echo "$github_ssh_known_host_entry" >> "$ssh_known_hosts_file"
fi
strap::ok

# piping the contents to awk to retain only the first two tokens (the third, if it exists, is the ssh key comment
# which GitHub does not store in its JSON, so any equality comparison would fail)
ssh_pub_key_contents="$(cat $ssh_pub_key | awk '{print $1 " " $2}')"
strap::github::api::user::keys::ensure "$github_token" "$ssh_pub_key_contents"

#############################################################
# Run Hook Packages:
#############################################################
if [[ "${#STRAP_RUN_HOOK_PACKAGES[@]}" -gt 0 ]]; then

  strap::bot "Run Hook Packages"

  strap::brew::ensure yq

  # ensure packages exist, or download and are valid:
  for package_id in "${STRAP_RUN_HOOK_PACKAGES[@]}"; do
    strap::pkg::ensure "$package_id"
    strap::pkg::hook::path "$package_id" run >/dev/null # validates the package automatically
  done

  for package_id in "${STRAP_RUN_HOOK_PACKAGES[@]}"; do
    dir="$(strap::pkg::id::dir "$package_id")"
    file="$(strap::pkg::hook::path "$package_id" run)"

    if ! bash "$file"; then
      strap::abort "Unable to execute package $package_id hook $file"
    fi
  done

fi


# make config/state a little more secure, just in case:
chmod -R go-rwx "$STRAP_USER_HOME"

STRAP_SUCCESS="1"
printf "\n${FONT_BOLD}${FONT_GREEN}SUCCESS: Your system is now Strap'd!${FONT_CLEAR}\n\n"
